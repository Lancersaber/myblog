---
title: 初始zookeeper
time: 2019-11-17
categories: zookeeper
tags: zookeeper
---

# 初始zookeeper
---

## Zookeeper介绍
Zookeeper是一个开放源代码的分布式协调服务。Zookeeper的设计目标是将那些复杂且容易出错的分布式一致性服务封装起来，构成一个高效可靠的原语集，并以一系列简单易用的接口提供给用户使用。

### Zookeeper是什么
Zookeeper是一个典型的分布式数据一致性的解决方案，分布式应用程序可以基于它实现诸如数据发布订阅、负载均衡，命名服务、分布式协调/通知、集群管理、Master选举、分布式锁和分布式队列等功能。Zookeeper可以保证如下分布式一致等特性

* 顺序一致性
* 原子性
* 单一试图
* 可靠性
* 实时性

### Zookeeper的设计目标
Zookeeper致力于提供一个高性能、高可用、且具有严格的顺序访问控制能力的分布式协调服务。下面我们来具体看一下Zookeeper的四个设计目标

#### 目标一：简单的数据模型
#### 目标二：可以构建集群
#### 目标三：顺序访问
#### 目标四：高性能

### Zookeeper的基本概念
下面介绍几个Zookeeper的核心概念

#### 集群角色
zookeeper中引用了Leader，Follower和Observer三种角色，Zookeeper集群中的所有机器通过一个Leader选举过程来选定一台被称为“Leader”的机器，Leader服务器为客户端提供读和写服务。Follower和Observer都能够提供读服务，唯一的区别在于，Observer机器不参与Leader的选举过程，也不参与写操作的“过半写成功”策略，因此Observer可以在不影响写性能的情况下提升集群的读性能。

#### 会话(Session)
Session是指客户端会话，在讲解会话之前，我们首先来了解一下客户端连接。在Zookeeper中，一个客户端连接是指客户端和服务器之间的一个TCP长连接。客户端启动的时候，首先会与服务器建立一个TCP连接，从第一次连接建立开始，客户端会话的生命周期也开始了，通过这个连接，客户端能够通过心跳检测与服务器保持有效的会话，也能够向Zookeeper服务器发送请求并接受响应，同时还能够通过该连接接收来自服务器的Watch事件通知。Session的session Timeout值用来设置一个客户端会话的超时时间。当由于服务器压力太大、网络故障或是客户端能够重新连接上集群中的任何一台服务器，那么之前场景的会话仍然有效。

#### 数据节点(Znode)

## Zookeeper的ZAB协议
ZAB(Zookeeper Atmoic Brodercast,原子消息广播协议)协议是为分布式协调服务Zookeeper专门设计的一种支持崩溃恢复的原子广播协议.
ZBA协议的核心是定义了对于那些会改变Zookeeper服务器数据状态的事务请求的处理方式，即：
```
所有事务请求必须由一个全局唯一的服务器来协调处理，这样的服务器被称为Leader服务器，而余下的其他服务器则成为Follower服务器。Leader服务器负责将一个客户端请求转换成一个事务Proposal(提议)，并将该Proposal分发给集群中所有的Follower服务器。之后Leader服务器需要等待所有Follower服务器的反馈，一旦超过半数的Follower服务器进行了正确的反馈后，那么Leaeder就会再次向所有的Follower服务器分发Commit消息，要求其将前一个Proposal进行提交。
```

### 协议介绍
ZAB协议包括了两种基本的模式，分别是崩溃恢复和消息广播。

#### 崩溃恢复
当整个服务框架在启动过程中，或是当Leader服务器出现网络中断、崩溃退出与重启等异常情况时，ZAB协议就会进入恢复模式并选举产生新的Leader服务器。当选举产生了新的Leader服务器，同时集群中已经有过半的机器与该Leader服务器完成了状态同步之后，ZAB协议就会退出恢复模式。其中，所谓的状态同步是指数据同步，用来保证集群中存在过半的机器能够和Leader服务器的数据状态保持一致。因此，ZAB协议需要一个高效且可靠的Leader选举算法，从而确保快速地选举新的Leader。同时，Leader选举算法不仅仅需要让Leader自己知道其自身已经被选举为新的Leader，同时还需要让集群中其他的所有机器也能够快速地感知到新选举的Leader服务器。

##### 基本特性
接下来我们看看在崩溃恢复过程中，可能会出现的两个数据不一致的隐患及针对这些情况ZAB协议所需要保证的特性。

*ZAB协议需要确保那些已经在Leader服务器上提交的事务最终被所有的服务器都提交*
假设一个事务在Leader服务器上都提交了，并且已经得到过半Follower服务器的Ack反馈，但是在它将Commit消息发送给所有的Follower机器之前，Leader服务器就挂了

*ZAB协议需要保证丢弃那些只在Leader服务器上被提交的事务*


#### 消息广播
当集群中已经有过半的Follower服务器完成了和Leader服务器的状态同步，那么整个服务器框架就可以进入消息广播模式。当一台同样遵守ZAB协议的服务器启动后加入到集群中，如果此时集群中已经存在一个Leader服务器在负责进行消息广播，那么新加入的服务器就会自觉地进入数据恢复模式：找到Leader所在的服务器，并与其进行数据同步，然后一起参与到消息广播流程中。如果集群中的其他机器接收到客户端的事务请求，那么这些非Leader服务器会首先将这个事务请求转发给Leader服务器。


 在整个消息广播过程中，Leader服务器会为每个事务请求生成对应的Proposal来进行广播，并且在广播事务Proposal之前，Leader服务器会首先为这个Proposal分配一个全局单调递增的唯一ID，我们称之为事务ID(即ZXID)。由于ZAB协议需要保证每一个消息的严格的因果关系，因此必须将每一个事务Proposal按照其ZXID的先后顺序来进行排序与处理。

 具体的，在消息广播过程中，Leader服务器会为每一个Follower服务器都各自分配一个单独的队列，然后将需要广播的事务Proposal依次放入这些队列中去，并且根据FIFO策略进行消息发送。每一个Follower服务器在接收到这个事务Proposal之后，都会首先将其以事务日志的形式写入到本地磁盘中去，并且在写入成功后反馈给Leader服务器一个Ack响应。当Leader服务器接收安东超过半数的Follower的Ack响应后，就会广播一个Commit消息给所有的Follower服务器以通知其进行事务提交，同时Leader自身也会完成对事务的提交，而每一个Follower服务器在接收到Commit消息后，也会完成对事务的提交。


