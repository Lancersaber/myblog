---
title: Shiro中的权限
time: 2019-11-04
categories: shiro
tags: shiro
---

# Shiro中的权限
---
Shiro将Permission定义为声明，该声明定义了明确的行为或动作。它是对应用程序中原始功能的声明，仅此而已。权限是安全策略中最底层的结构，它们明确定义仅应用程序可以执行的“操作”。

他们根本没有描述“谁”能够执行这些动作。
权限的一些示例：

* 开启档案
* 查看“ /用户/列表”网页
* 列印文件
* 删除“ jsmith”用户

定义允许“谁”（用户）执行“什么”（权限）是一种以某种方式向用户分配权限的练习。这始终由应用程序的数据模型完成，并且在不同应用程序之间可能会有很大差异。

例如，权限可以分组在一个角色中，并且该角色可以与一个或多个用户对象相关联。或者某些应用程序可以具有一个用户组，并且可以为一个组分配一个角色，这通过传递关联将意味着该组中的所有用户都隐式地获得了该角色中的权限。

如何授予用户权限有很多变体-应用程序根据应用程序需求确定如何对此建模。

## 通配符权限
上面的权限示例，“打开文件”，“查看'用户/列表'网页”等都是有效的权限声明。但是，在计算上解释这些自然语言字符串并确定是否允许用户执行该行为将非常困难。

因此，为了启用易于处理但仍可读的权限声明，Shiro提供了强大而直观的权限语法，我们称之为WildcardPermission。

### 简单用法
假设您要保护对公司打印机的访问权限，以便某些人可以打印到特定打印机，而其他人可以查询队列中当前有哪些作业。

一种非常简单的方法是向用户授予“ queryPrinter”权限。然后，您可以通过调用以下命令来检查用户是否具有queryPrinter权限：

```
subject.isPermitted("queryPrinter")
```

这（主要）相当于
```
subject.isPermitted( new WildcardPermission("queryPrinter") )
```
但以后会更多。

简单权限字符串可能适用于简单应用程序，但是它要求您具有“ printPrinter”，“ queryPrinter”，“ managePrinter”等权限。您还可以使用通配符向用户授予“ \*”权限（赋予此权限构造其名称），这意味着它们拥有整个应用程序的所有权限。

但是，使用这种方法无法仅说用户具有“所有打印机权限”。因此，通配符权限支持多个级别的权限。

### Multiple Parts
通配符权限支持多个级别或部分的概念。例如，您可以通过向用户授予权限来重组前面的简单示例
```
printer:query
```

在此示例中，冒号是一个特殊字符，用于分隔权限字符串中的下一部分。

在此示例中，第一部分是正在（printer）上操作的域，第二部分是query正在执行的动作（）。上面的其他示例将更改为：

```
printer:print
printer:manage
```

可以使用的部件数量没有限制，因此可以在应用程序中使用的方式取决于您的想象。

### 多个值
每个部分可以包含多个值。因此，除了向用户授予“ printer：print”和“ printer：query”权限之外，您还可以向他们授予一个权限：
```
printer:print,query
```

这使他们能够使用print和query打印机。由于这两个操作都被授予，因此您可以通过调用以下命令来检查用户是否具有查询打印机的能力：
```
subject.isPermitted("printer:query")
```

### 所有值
如果您想授予用户特定部分的所有值怎么办？这样做比手动列出每个值更方便。同样，基于通配符，我们可以执行此操作。如果printer域有3个可能的行动（query，print，和manage），这一点：
```
printer:query,print,manage
```

变成这样：
```
printer:*
```

然后，将返回对“ printer：XXX”的任何权限检查true。以这种方式使用通配符的扩展性比显式列出操作更好，因为如果以后在应用程序中添加了新操作，则无需更新在该部分中使用通配符的权限。

最后，也可以在通配符权限字符串的任何部分中使用通配符。例如，如果您想授予用户跨所有域（而不仅仅是打印机）的“查看”操作，则可以授予此权限：
```
*:view
```

然后，任何对“ foo：view”的权限检查都将返回 true

### 实例级访问控制
通配符权限的另一种常见用法是为实例级访问控制列表建模。在这种情况下，您使用三个部分-第一部分是domain(域)，第二部分是action(操作)，第三部分是要执行的instance(实例)。

例如，您可能有
```
printer:query:lp7200
printer:print:epsoncolor
```

第一个定义的行为，以query在printer与该ID lp7200。第二权限定义的行为，以print到printer用ID epsoncolor。如果您将这些权限授予用户，则他们可以在特定实例上执行特定行为。然后，您可以执行签入代码：
```
if ( SecurityUtils.getSubject().isPermitted("printer:query:lp7200") {
    // Return the current jobs on printer lp7200 }
}
```
这是表达权限的一种非常强大的方法。但是同样，必须为所有打印机定义多个实例ID不能很好地扩展，特别是在将新打印机添加到系统中时。您可以改用通配符:
```
printer:print:*
```

这确实可以扩展，因为它也适用于所有新打印机。您甚至可以允许访问所有打印机上的所有操作：
```
printer:*:*
```

或单个打印机上的所有操作：
```
printer:*:lp7200
```

甚至特定的动作：
```
printer:query,print:lp7200
```

许可的任何部分都可以使用“ \*”通配符和“，”子部分分隔符。

### 缺少的部分
关于权限分配要注意的最后一件事：缺少部分意味着用户可以访问与该部分相对应的所有值。换一种说法，
```
printer:print
```

相当于
```
printer:print:*
```
和
```
printer
```

相当于
```
printer:*:*
```

但是，您只能从字符串末尾删除部分，因此：
```
printer:lp7200
```

不等同于
```
printer:*:lp7200
```

## 检查权限
为了方便和可扩展性，权限分配大量使用通配符结构（“ printer：print：\*” =可打印到任何打印机），但运行时的权限检查应始终基于最具体的权限字符串。

例如，如果用户具有UI，并且他们想要将文档打印到lp7200打印机，则应通过执行以下代码来检查是否允许用户这样做：

```
if ( SecurityUtils.getSubject().isPermitted("printer:print:lp7200") ) {
    //print the document to the lp7200 printer }
}
```

该检查非常具体，并且明确反映了用户当时正在尝试执行的操作。

但是，以下内容对于运行时检查不太理想
```
if ( SecurityUtils.getSubject().isPermitted("printer:print") ) {
    //print the document }
}
```

为什么？因为第二个示例显示“您必须能够打印到任何打印机才能执行以下代码块”。但是请记住，“ printer：print”等同于“ printer：print：\*”！

因此，这是不正确的检查。如果当前用户没有能力打印到任何打印机，但是他们确实有能力打印说lp7200和epsoncolor打印机，该怎么办。然后，lp7200即使已被授予该功能，上面的第二个示例也将永远不允许它们打印到打印机上！

因此，经验法则是在执行权限检查时，尽可能使用最具体的权限字符串。当然，如果您确实只想在允许用户使用任何打印机进行打印的情况下仅执行代码块，则上面的第二个块可能是应用程序中其他地方的有效检查（可疑，但可能）。您的应用程序将确定哪些检查有意义，但总的来说，检查越具体越好。

### Implication, not Equality
为什么运行时权限检查应尽可能具体，但权限分配却可能更通用？这是因为权限检查是通过隐含逻辑进行评估的，而不是相等性检查。

也就是说，如果为用户分配了user:*权限，则意味着该用户可以执行该user:view操作。字符串“ user：\*”显然不等于“ user：view”，但是前者暗含后者。“用户：*”描述了“用户：视图”所定义功能的超集。

为了支持隐含规则，所有权限都转换为实现该org.apache.shiro.authz.Permission接口的对象实例。这样，隐含逻辑可以在运行时执行，并且隐含逻辑通常比简单的字符串相等性检查更复杂。org.apache.shiro.authz.permission.WildcardPermission该类实现实际上使本文档中描述的所有通配符行为成为可能。以下是一些其他通配符权限字符串，这些字符串通过含义显示访问权限：
```
user:*
```

意味着还可以删除用户：
```
user:delete
```

同样，
```
user:*:12345
```

表示还可以更新ID 12345的用户帐户：
```
user:update:12345
```

